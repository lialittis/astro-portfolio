---
title: Security News – 2025-12-04
date: 2025-12-04
tags: [security, news]
---

## The Hacker News
*Cybersecurity news and insights*

### [Critical RSC Bugs in React and Next.js Allow Unauthenticated Remote Code Execution](https://thehackernews.com/2025/12/critical-rsc-bugs-in-react-and-nextjs.html) - December 03, 2025

A maximum-severity security flaw has been disclosed in React Server Components (RSC) that, if successfully exploited, could result in remote code execution.
The vulnerability, tracked as CVE-2025-55182, carries a CVSS score of 10.0.
It allows "unauthenticated remote code execution by exploiting a flaw in how React decodes payloads sent to React Server Function endpoints," the React Team said in

### [Discover the AI Tools Fueling the Next Cybercrime Wave — Watch the Webinar](https://thehackernews.com/2025/12/discover-ai-tools-fueling-next.html) - December 03, 2025

Remember when phishing emails were easy to spot? Bad grammar, weird formatting, and requests from a "Prince" in a distant country?
Those days are over.
Today, a 16-year-old with zero coding skills and a $200 allowance can launch a campaign that rivals state-sponsored hackers. They don't need to be smart; they just need to subscribe to the right AI tool.
We are witnessing the industrialization of

### [Microsoft Silently Patches Windows LNK Flaw After Years of Active Exploitation](https://thehackernews.com/2025/12/microsoft-silently-patches-windows-lnk.html) - December 03, 2025

Microsoft has silently plugged a security flaw that has been exploited by several threat actors since 2017 as part of the company's November 2025 Patch Tuesday updates, according to ACROS Security's 0patch.
The vulnerability in question is CVE-2025-9491 (CVSS score: 7.8/7.0), which has been described as a Windows Shortcut (LNK) file UI misinterpretation vulnerability that could lead to remote

### [WordPress King Addons Flaw Under Active Attack Lets Hackers Make Admin Accounts](https://thehackernews.com/2025/12/wordpress-king-addons-flaw-under-active.html) - December 03, 2025

A critical security flaw impacting a WordPress plugin known as King Addons for Elementor has come under active exploitation in the wild.
The vulnerability, CVE-2025-8489 (CVSS score: 9.8), is a case of privilege escalation that allows unauthenticated attackers to grant themselves administrative privileges by simply specifying the administrator user role during registration.
It affects versions


## Google Security Blog
*Security insights from Google*

### [Android expands pilot for in-call scam protection for financial apps](http://security.googleblog.com/2025/12/android-expands-pilot-in-call-scam-protection-financial-apps.html) - December 03, 2025

<span class="byline-author">Posted by Aden Haussmann, Associate Product Manager and Sumeet Sharma, Play Partnerships Trust & Safety Lead</span>

<p>
Android uses the best of Google AI and our advanced security expertise to tackle mobile scams from every angle. Over the last few years, we’ve launched industry-leading features to detect scams and protect users across <a href="https://security.googleblog.com/2025/03/new-ai-powered-scam-detection-features.html">phone calls, text messages</a> and <a href="https://blog.google/products/pixel/november-2025-pixel-drop/">messaging app chat notifications</a>.
</p>
<p>
These efforts are making a real difference in the lives of Android users. According to a recent YouGov <a href="https://security.googleblog.com/2025/10/how-android-protects-you-from-scams.html">survey</a><sup id="fnref1"><a href="https://feeds.feedburner.com/GoogleOnlineSecurityBlog#fn1" rel="footnote">1</a></sup> commissioned by Google, Android users were 58% more likely than iOS users to report they had not received any scam texts in the prior week<sup id="fnref2"><a href="https://feeds.feedburner.com/GoogleOnlineSecurityBlog#fn2" rel="footnote">2</a></sup>. 
</p>
<p>
But our work doesn’t stop there. Scammers are continuously evolving, using more sophisticated social engineering tactics to trick users into sharing their phone screen while on the phone to visit malicious websites, reveal sensitive information, send funds or download harmful apps. One popular scam involves criminals impersonating banks or other trusted institutions on the phone to try to manipulate victims into sharing their screen in order to reveal banking information or make a financial transfer. 
</p>
<p>
To help combat these types of financial scams, we <a href="https://security.googleblog.com/2025/05/whats-new-in-android-security-privacy-2025.html">launched a pilot earlier this year in the UK</a> focused on in-call protections for financial apps.
</p>
<p>
<strong>How the in-call scam protection works on Android</strong>
</p>
<p>
When you launch a participating financial app while screen sharing and on a phone call with a number that is not saved in your contacts, your Android device<sup id="fnref3"><a href="https://feeds.feedburner.com/GoogleOnlineSecurityBlog#fn3" rel="footnote">3</a></sup> will automatically warn you about the potential dangers and give you the option to end the call and to stop screen sharing with just one tap. The warning includes a 30-second pause period before you’re able to continue, which helps break the ‘spell’ of the scammer's social engineering, disrupting the false sense of urgency and panic commonly used to manipulate you into a scam.
</p>
<div class="separator" style="clear: both;"><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiGCqea99OZsjlhcQnFHdWF-aF6d7sw9fw_yDU7se3u4Kd0LvqyBGkV-GNNYN9PnQlnBYAcykAWEtsDDKZX2ykJtJwuYIQF04WKiuMCEnaKdbFy4mkZb_1XY3hvehAZjYYEaLWYp3GoVz4hkwkrqzjI0T_vC2gsTRHXMk4jYZJ5A3b_b-dWQavQMtZESTuY/s3840/BankScamWarning_20251203.png" style="display: block; padding: 1em 0; text-align: center;"><img alt="" border="0" height="600" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiGCqea99OZsjlhcQnFHdWF-aF6d7sw9fw_yDU7se3u4Kd0LvqyBGkV-GNNYN9PnQlnBYAcykAWEtsDDKZX2ykJtJwuYIQF04WKiuMCEnaKdbFy4mkZb_1XY3hvehAZjYYEaLWYp3GoVz4hkwkrqzjI0T_vC2gsTRHXMk4jYZJ5A3b_b-dWQavQMtZESTuY/s600/BankScamWarning_20251203.png" /></a></div>
<strong>Bringing in-call scam protections to more users on Android</strong>
</p>
<p>
The UK pilot of Android’s in-call scam protections has already helped thousands of users end calls that could have cost them a significant amount of money. Following this success, and alongside recently launched pilots with financial apps in <a href="https://blog.google/intl/pt-br/produtos/android-chrome-play/novas-protecoes-contra-roubo-e-fraude-comecando-pelo-brasil/">Brazil</a> and <a href="https://blog.google/intl/en-in/company-news/protecting-vulnerable-audiences-is-at-the-heart-of-ai-safety-efforts/">India</a>, we’ve now expanded this protection to most major UK banks.<del> </del><br /><br />We’ve also started to pilot this protection with more app types, including peer-to-peer (P2P) payment apps. Today, we’re taking the next step in our expansion by rolling out a pilot of this protection in the United States<sup id="fnref4"><a href="https://feeds.feedburner.com/GoogleOnlineSecurityBlog#fn4" rel="footnote">4</a></sup> with a number of popular fintechs like Cash App and banks, including JPMorganChase. <br /><br />We are committed to collaborating across the ecosystem to help keep people safe from scams. We look forward to learning from these pilots and bringing these critical safeguards to even more users in the future.
</p>

<!-- Footnotes themselves at the bottom. -->

<h2>Notes</h2>
<div class="footnotes">
<hr />
<ol><li id="fn1">
<p>
     <em> Google/YouGov survey, July-August, n=5,100 (1,700 each in the US, Brazil and India), with adults who use their smartphones daily and who have been exposed to a scam or fraud attempt on their smartphone. Survey data have been weighted to smartphone population adults in each country. </em>&nbsp;<a href="https://feeds.feedburner.com/GoogleOnlineSecurityBlog#fnref1" rev="footnote">&#8617;</a><li id="fn2">
<p>
     <em> Among users who use the default texting app on their smartphone. </em>&nbsp;<a href="https://feeds.feedburner.com/GoogleOnlineSecurityBlog#fnref2" rev="footnote">&#8617;</a><li id="fn3">
<p>
    <em> Compatible with Android 11+ devices</em>&nbsp;<a href="https://feeds.feedburner.com/GoogleOnlineSecurityBlog#fnref3" rev="footnote">&#8617;</a><li id="fn4">
<p>
    <em>US users of the US versions of the apps; rollout begins Dec. 2025</em>&nbsp;<a href="https://feeds.feedburner.com/GoogleOnlineSecurityBlog#fnref4" rev="footnote">&#8617;</a>

</ol></div>


## The Hacker News
*Cybersecurity news and insights*

### [Brazil Hit by Banking Trojan Spread via WhatsApp Worm and RelayNFC NFC Relay Fraud](https://thehackernews.com/2025/12/brazil-hit-by-banking-trojan-spread-via.html) - December 03, 2025

The threat actor known as Water Saci is actively evolving its tactics, switching to a sophisticated, highly layered infection chain that uses HTML Application (HTA) files and PDFs to propagate via WhatsApp a worm that deploys a banking trojan in attacks targeting users in Brazil.
The latest wave is characterized by the attackers shifting from PowerShell to a Python-based variant that spreads the


## SecurityWeek
*Latest cybersecurity news*

### [Niobium Raises $23 Million for FHE Hardware Acceleration](https://www.securityweek.com/niobium-raises-23-million-for-fhe-hardware-acceleration/) - December 03, 2025

<p>The startup will invest the funds in accelerating development of its second-generation fully homomorphic encryption (FHE) platforms.</p>
<p>The post <a href="https://www.securityweek.com/niobium-raises-23-million-for-fhe-hardware-acceleration/">Niobium Raises $23 Million for FHE Hardware Acceleration</a> appeared first on <a href="https://www.securityweek.com">SecurityWeek</a>.</p>

### [Critical King Addons Vulnerability Exploited to Hack WordPress Sites](https://www.securityweek.com/critical-king-addons-vulnerability-exploited-to-hack-wordpress-sites/) - December 03, 2025

<p>A critical-severity vulnerability in the King Addons for Elementor plugin for WordPress has been exploited to take over websites.</p>
<p>The post <a href="https://www.securityweek.com/critical-king-addons-vulnerability-exploited-to-hack-wordpress-sites/">Critical King Addons Vulnerability Exploited to Hack WordPress Sites</a> appeared first on <a href="https://www.securityweek.com">SecurityWeek</a>.</p>

### [Arizona Attorney General Sues Chinese Online Retailer Temu Over Data Theft Claims](https://www.securityweek.com/arizona-attorney-general-sues-chinese-online-retailer-temu-over-data-theft-claims/) - December 03, 2025

<p>Arizona is the latest state to sue Temu and its parent company PDD Holdings over allegations that the Chinese online retailer is stealing customers’ data.</p>
<p>The post <a href="https://www.securityweek.com/arizona-attorney-general-sues-chinese-online-retailer-temu-over-data-theft-claims/">Arizona Attorney General Sues Chinese Online Retailer Temu Over Data Theft Claims</a> appeared first on <a href="https://www.securityweek.com">SecurityWeek</a>.</p>

### [ServiceNow to Acquire Identity Security Firm Veza in Reported $1 Billion Deal](https://www.securityweek.com/servicenow-to-acquire-identity-security-firm-veza-in-reported-1-billion-deal/) - December 03, 2025

<p>Veza Security was recently valued at more than $800 million after raising $108 million in Series D funding.</p>
<p>The post <a href="https://www.securityweek.com/servicenow-to-acquire-identity-security-firm-veza-in-reported-1-billion-deal/">ServiceNow to Acquire Identity Security Firm Veza in Reported $1 Billion Deal </a> appeared first on <a href="https://www.securityweek.com">SecurityWeek</a>.</p>

### [Penn and Phoenix Universities Disclose Data Breach After Oracle Hack](https://www.securityweek.com/penn-and-phoenix-universities-disclose-data-breach-after-oracle-hack/) - December 03, 2025

<p>The University of Pennsylvania and the University of Phoenix confirm that they are victims of the recent Oracle EBS hacking campaign.</p>
<p>The post <a href="https://www.securityweek.com/penn-and-phoenix-universities-disclose-data-breach-after-oracle-hack/">Penn and Phoenix Universities Disclose Data Breach After Oracle Hack</a> appeared first on <a href="https://www.securityweek.com">SecurityWeek</a>.</p>

### [Microsoft Silently Mitigated Exploited LNK Vulnerability](https://www.securityweek.com/microsoft-silently-mitigated-exploited-lnk-vulnerability/) - December 03, 2025

<p>Windows now displays in the properties tab of LNK files critical information that could reveal malicious code.</p>
<p>The post <a href="https://www.securityweek.com/microsoft-silently-mitigated-exploited-lnk-vulnerability/">Microsoft Silently Mitigated Exploited LNK Vulnerability</a> appeared first on <a href="https://www.securityweek.com">SecurityWeek</a>.</p>


## The Hacker News
*Cybersecurity news and insights*

### [Chopping AI Down to Size: Turning Disruptive Technology into a Strategic Advantage](https://thehackernews.com/2025/12/chopping-ai-down-to-size-turning.html) - December 03, 2025

Most people know the story of Paul Bunyan. A giant lumberjack, a trusted axe, and a challenge from a machine that promised to outpace him. Paul doubled down on his old way of working, swung harder, and still lost by a quarter inch. His mistake was not losing the contest. His mistake was assuming that effort alone could outmatch a new kind of tool.
Security professionals are facing a similar

### [Picklescan Bugs Allow Malicious PyTorch Models to Evade Scans and Execute Code](https://thehackernews.com/2025/12/picklescan-bugs-allow-malicious-pytorch.html) - December 03, 2025

Three critical security flaws have been disclosed in an open-source utility called Picklescan that could allow malicious actors to execute arbitrary code by loading untrusted PyTorch models, effectively bypassing the tool's protections.
Picklescan, developed and maintained by Matthieu Maitre (@mmaitre314), is a security scanner that's designed to parse Python pickle files and detect suspicious


## SecurityWeek
*Latest cybersecurity news*

### [Chrome 143 Patches High-Severity Vulnerabilities](https://www.securityweek.com/chrome-143-patches-high-severity-vulnerabilities/) - December 03, 2025

<p>Chrome 143 stable was released with patches for 13 vulnerabilities, including a high-severity flaw in the V8 JavaScript engine.</p>
<p>The post <a href="https://www.securityweek.com/chrome-143-patches-high-severity-vulnerabilities/">Chrome 143 Patches High-Severity Vulnerabilities</a> appeared first on <a href="https://www.securityweek.com">SecurityWeek</a>.</p>


## The Hacker News
*Cybersecurity news and insights*

### [Malicious Rust Crate Delivers OS-Specific Malware to Web3 Developer Systems](https://thehackernews.com/2025/12/malicious-rust-crate-delivers-os.html) - December 03, 2025

Cybersecurity researchers have discovered a malicious Rust package that's capable of targeting Windows, macOS, and Linux systems, and features malicious functionality to stealthily execute on developer machines by masquerading as an Ethereum Virtual Machine (EVM) unit helper tool.
The Rust crate, named "evm-units," was uploaded to crates.io in mid-April 2025 by a user named "ablerust,"

### [India Orders Messaging Apps to Work Only With Active SIM Cards to Prevent Fraud and Misuse](https://thehackernews.com/2025/12/india-orders-messaging-apps-to-work.html) - December 02, 2025

India's Department of Telecommunications (DoT) has issued directions to app-based communication service providers to ensure that the platforms cannot be used without an active SIM card linked to the user's mobile number.
To that end, messaging apps like WhatsApp, Telegram, Snapchat, Arattai, Sharechat, Josh, JioChat, and Signal that use an Indian mobile number for uniquely identifying their


## SecurityWeek
*Latest cybersecurity news*

### [Zafran Security Raises $60 Million in Series C Funding](https://www.securityweek.com/zafran-security-raises-60-million-in-series-c-funding/) - December 02, 2025

<p>The cybersecurity startup will use the investment to accelerate product innovation and global expansion.</p>
<p>The post <a href="https://www.securityweek.com/zafran-security-raises-60-million-in-series-c-funding/">Zafran Security Raises $60 Million in Series C Funding</a> appeared first on <a href="https://www.securityweek.com">SecurityWeek</a>.</p>


## Schneier on Security
*Security news and analysis by Bruce Schneier*

### [Like Social Media, AI Requires Difficult Choices](https://www.schneier.com/blog/archives/2025/12/like-social-media-ai-requires-difficult-choices.html) - December 02, 2025

<p>In his 2020 book, &#8220;<a href="https://global.oup.com/academic/product/future-politics-9780198825616?cc=ca&#38;lang=en&#38;">Future Politics</a><em>,</em>&#8221; British barrister Jamie Susskind wrote that the dominant question of the 20th century was &#8220;How much of our collective life should be determined by the state, and what should be left to the market and civil society?&#8221; But in the early decades of this century, Susskind suggested that we face a different question: &#8220;To what extent should our lives be directed and controlled by powerful digital systems&#8212;and on what terms?&#8221;</p>
<p>Artificial intelligence (AI) forces us to confront this question. It is a technology that in theory amplifies the power of its users: A manager, marketer, political campaigner, or opinionated internet user can utter a single instruction, and see their message&#8212;whatever it is&#8212;instantly written, personalized, and propagated via email, text, social, or other channels to thousands of people within their organization, or millions around the world. It also allows us to individualize solicitations for political donations, elaborate a grievance into a well-articulated policy position, or tailor a persuasive argument to an identity group, or even a single person...</p>


## Trail of Bits Blog
*Security research and insights from Trail of Bits*

### [Introducing constant-time support for LLVM to protect cryptographic code](https://blog.trailofbits.com/2025/12/02/introducing-constant-time-support-for-llvm-to-protect-cryptographic-code/) - December 02, 2025

<p>Trail of Bits has developed <a href="https://github.com/llvm/llvm-project/pull/166702">constant-time coding support for LLVM</a>, providing developers with compiler-level guarantees that their cryptographic implementations remain secure against branching-related timing attacks. These changes are being reviewed and will be added in an upcoming release, LLVM 22. This work introduces the <code>__builtin_ct_select</code> family of intrinsics and supporting infrastructure that prevents the Clang compiler, and potentially other compilers built with LLVM, from inadvertently breaking carefully crafted constant-time code. This post will walk you through what we built, how it works, and what it supports. We’ll also discuss some of our future plans for extending this work.</p>
<h2 id="the-compiler-optimization-problem">The compiler optimization problem</h2>
<p>Modern compilers excel at making code run faster. They eliminate redundant operations, vectorize loops, and cleverly restructure algorithms to squeeze out every bit of performance. But this optimization zeal becomes a liability when dealing with cryptographic code.</p>
<p>Consider this seemingly innocent constant-time lookup from <a href="https://electricdusk.com/cmov-conversion.html">Sprenkels (2019)</a>:</p>
<figure class="highlight">
 <pre class="chroma" tabindex="0"><code class="language-c"><span class="line"><span class="cl"><span class="kt">uint64_t</span> <span class="nf">constant_time_lookup</span><span class="p">(</span><span class="k">const</span> <span class="kt">size_t</span> <span class="n">secret_idx</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"> <span class="k">const</span> <span class="kt">uint64_t</span> <span class="n">table</span><span class="p">[</span><span class="mi">16</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="kt">uint64_t</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">const</span> <span class="kt">bool</span> <span class="n">cond</span> <span class="o">=</span> <span class="n">i</span> <span class="o">==</span> <span class="n">secret_idx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="k">const</span> <span class="kt">uint64_t</span> <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="kt">int64_t</span><span class="p">)</span><span class="n">cond</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="n">result</span> <span class="o">|=</span> <span class="n">table</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">return</span> <span class="n">result</span><span class="p">;}</span></span></span></code></pre>
</figure>
<p>This code carefully avoids branching on the secret index. Every iteration executes the same operations regardless of the secret value. However, as compilers are built to make your code go faster, they would see an opportunity to improve this carefully crafted code by optimizing it into a version that includes branching.</p>
<p>The problem is that any data-dependent behavior in the compiled code would create a timing side channel. If the compiler introduces a branch like <code>if (i == secret_idx)</code>, the CPU will take different amounts of time depending on whether the branch is taken. Modern CPUs have branch predictors that learn patterns, making correctly predicted branches faster than mispredicted ones. An attacker who can measure these timing differences across many executions can statistically determine which index is being accessed, effectively recovering the secret. Even small timing variations of a few CPU cycles can be exploited with sufficient measurements.</p>
<h2 id="what-we-built">What we built</h2>
<p>Our solution provides cryptographic developers with explicit compiler intrinsics that preserve constant-time properties through the entire compilation pipeline. The core addition is the <code>__builtin_ct_select</code> family of intrinsics:</p>
<figure class="highlight">
 <pre class="chroma" tabindex="0"><code class="language-c"><span class="line"><span class="cl"><span class="c1">// Constant-time conditional selection
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">result</span> <span class="o">=</span> <span class="nf">__builtin_ct_select</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">value_if_true</span><span class="p">,</span> <span class="n">value_if_false</span><span class="p">);</span></span></span></code></pre>
</figure>
<p>This intrinsic guarantees that the selection operation above will compile to constant-time machine code, regardless of optimization level. When you write this in your C/C++ code, the compiler translates it into a special LLVM intermediate representation intrinsic (llvm.ct.select.*) that carries semantic meaning: &ldquo;this operation must remain constant-time.&rdquo;</p>
<p>Unlike regular code that the optimizer freely rearranges and transforms, this intrinsic acts as a barrier. The optimizer recognizes it as a security-critical operation and preserves its constant-time properties through every compilation stage, from source code to assembly.</p>
<h2 id="real-world-impact">Real-world impact</h2>
<p>In their recent study “<a href="https://arxiv.org/pdf/2410.13489.pdf">Breaking Bad: How Compilers Break Constant-Time Implementations</a>,” Srdjan Čapkun and his graduate students Moritz Schneider and Nicolas Dutly found that compilers break constant-time guarantees in numerous production cryptographic libraries. Their analysis of 19 libraries across five compilers revealed systematic vulnerabilities introduced during compilation.</p>
<p>With our intrinsics, the problematic lookup function becomes this constant-time version:</p>
<figure class="highlight">
 <pre class="chroma" tabindex="0"><code class="language-c"><span class="line"><span class="cl"><span class="kt">uint64_t</span>
</span></span><span class="line"><span class="cl"><span class="nf">constant_time_lookup</span><span class="p">(</span><span class="k">const</span> <span class="kt">size_t</span> <span class="n">secret_idx</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"> <span class="k">const</span> <span class="kt">uint64_t</span> <span class="n">table</span><span class="p">[</span><span class="mi">16</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="kt">uint64_t</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">const</span> <span class="kt">bool</span> <span class="n">cond</span> <span class="o">=</span> <span class="n">i</span> <span class="o">==</span> <span class="n">secret_idx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="n">result</span> <span class="o">|=</span> <span class="nf">__builtin_ct_select</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="n">table</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">0u</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl"> <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre>
</figure>
<p>The use of an intrinsic function prevents the compiler from making any modifications to it, which ensures the selection remains constant time. No optimization pass will transform it into a vulnerable memory access pattern.</p>
<h2 id="community-engagement-and-adoption">Community engagement and adoption</h2>
<p>Getting these changes upstream required extensive community engagement. We published our <a href="https://discourse.llvm.org/t/rfc-constant-time-coding-support/87781">RFC on the LLVM Discourse</a> forum in August 2025.</p>
<p>The RFC received significant feedback from both the compiler and cryptography communities. Open-source maintainers from Rust Crypto, BearSSL, and PuTTY expressed strong interest in adopting these intrinsics to replace their current inline assembly workarounds, while providing valuable feedback on implementation approaches and future primitives. LLVM developers helped ensure the intrinsics work correctly with auto-vectorization and other optimization passes, along with architecture-specific implementation guidance.</p>
<h3 id="building-on-existing-work">Building on existing work</h3>
<p>Our approach synthesizes lessons from multiple previous efforts:</p>
<ul>
<li><a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=8406587"><strong>Simon and Chisnall <code>__builtin_ct_choose</code></strong> (2018)</a>: This work provided the conceptual foundation for compiler intrinsics that preserve constant-time properties, but was never upstreamed.</li>
<li><a href="https://acmccs.github.io/papers/p1807-almeidaA.pdf"><strong>Jasmin</strong> (2017)</a>: This work showed the value of compiler-aware constant-time primitives but would have required a new language.</li>
<li><strong>Rust&rsquo;s <code>#[optimize(never)]</code></strong> experiments: These experiments highlighted the need for fine-grained optimization control.</li>
</ul>
<h2 id="how-it-works-across-architectures">How it works across architectures</h2>
<p>Our implementation ensures <code>__builtin_ct_select</code> compiles to constant-time code on every platform:</p>
<p><strong>x86-64:</strong> The intrinsic compiles directly to the <strong><code>cmov</code></strong> (conditional move) instruction, which always executes in constant time regardless of the condition value.</p>
<p><strong>i386:</strong> Since i386 lacks <code>cmov</code>, we use a masked arithmetic pattern with bitwise operations to achieve constant-time selection.</p>
<p><strong>ARM and AArch64:</strong> For AArch64, the intrinsic is lowered to the CSEL instruction, which provides constant-time execution. For ARM, since ARMv7 doesn’t have a constant-time instruction like AAarch64, the implementation generates a masked arithmetic pattern using bitwise operations instead.</p>
<p><strong>Other architectures:</strong> A generic fallback implementation uses bitwise arithmetic to ensure constant-time execution, even on platforms we haven&rsquo;t natively added support for.</p>
<p>Each architecture needs different instructions to achieve constant-time behavior. Our implementation handles these differences transparently, so developers can write portable constant-time code without worrying about platform-specific details.</p>
<h2 id="benchmarking-results">Benchmarking results</h2>
<p>Our partners at ETH Zürich are conducting comprehensive benchmarking using their test suite from the &ldquo;Breaking Bad&rdquo; study. Initial results show the following:</p>
<ul>
<li><strong>Minimal performance overhead</strong> for most cryptographic operations</li>
<li><strong>100% preservation</strong> of constant-time properties across all tested optimization levels</li>
<li><strong>Successful integration</strong> with major cryptographic libraries including HACL*, Fiat-Crypto, and BoringSSL</li>
</ul>
<h2 id="whats-next">What&rsquo;s next</h2>
<p>While <code>__builtin_ct_select</code> addresses the most critical need, our RFC outlines a roadmap for additional intrinsics:</p>
<h3 id="constant-time-operations">Constant-time operations</h3>
<p>We have future plans for extending the constant-time implementation, specifically for targeting arithmetic or string operations and evaluating expressions to be constant time.</p>
<figure class="highlight">
 <pre class="chroma" tabindex="0"><code class="language-c"><span class="line"><span class="cl"><span class="n">_builtin_ct</span><span class="o">&lt;</span><span class="n">op</span><span class="o">&gt;</span> <span class="c1">// for constant-time arithmetic or string operation
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">__builtin_ct_expr</span><span class="p">(</span><span class="n">expression</span><span class="p">)</span> <span class="c1">// Force entire expression to evaluate without branches
</span></span></span></code></pre>
</figure>
<h3 id="adoption-path-for-other-languages">Adoption path for other languages</h3>
<p>The modular nature of our LLVM implementation means any language targeting LLVM can leverage this work:</p>
<p><strong>Rust:</strong> The Rust compiler team is exploring how to expose these intrinsics through its <code>core::intrinsics</code> module, potentially providing safe wrappers in the standard library.</p>
<p><strong>Swift:</strong> Apple&rsquo;s security team has expressed interest in adopting these primitives for its cryptographic frameworks.</p>
<p><strong>WebAssembly:</strong> These intrinsics would be particularly useful for browser-based cryptography, where timing attacks remain a concern despite sandboxing.</p>
<h2 id="acknowledgments">Acknowledgments</h2>
<p>This work was done in collaboration with the <a href="https://syssec.ethz.ch/">System Security Group</a> at ETH Zürich. Special thanks to Laurent Simon and David Chisnall for their pioneering work on constant-time compiler support, and to the LLVM community for their constructive feedback during the RFC process.</p>
<p>We&rsquo;re particularly grateful to our Trail of Bits cryptography team for its technical review.</p>
<h2 id="resources">Resources</h2>
<ul>
<li><a href="https://discourse.llvm.org/t/rfc-constant-time-coding-support/87781">RFC: Constant-Time Coding Support</a></li>
<li><a href="https://www.youtube.com/watch?v=zLBEXGTdd6o&amp;t=3s">LLVM Developers&rsquo; Meeting 2025: Constant-Time Intrinsics Presentation Talk</a></li>
<li><a href="https://arxiv.org/pdf/2410.13489.pdf">ETH Zürich&rsquo;s &ldquo;Breaking Bad&rdquo; Study</a></li>
<li><a href="https://blog.trailofbits.com/2022/01/26/part-1-the-life-of-an-optimization-barrier/">Part 1: The life of an optimization barrier (Trail of Bits blog)</a></li>
<li><a href="https://blog.trailofbits.com/2022/02/01/part-2-rusty-crypto/">Part 2: Improving crypto code in Rust using LLVM’s optnone (Trail of Bits blog)</a></li>
</ul>
<hr />
<p>The work to which this blog post refers was conducted by Trail of Bits based upon work supported by DARPA under Contract No. N66001-21-C-4027 (Distribution Statement A, Approved for Public Release: Distribution Unlimited). Any opinions, findings and conclusions or recommendations expressed in this material are those of the author(s) and do not necessarily reflect the views of the United States Government or DARPA.</p>


## Nebelwelt
*Security research and insights*

### [AISec and the exploration of the Chinese soul](https://nebelwelt.net/blog/2025/1130-aisec.html) - November 30, 2025

<p>Just a few weeks ago, <a class="reference external" href="https://netsec.ccert.edu.cn/people/chaoz/">Chao Zhang</a>
invited me to a workshop in AI security at Tsinghua University in Beijing. Chao
and myself overlapped as post docs in Dawn Song's BitBlaze group at UC Berkeley
and we're both deeply interested in low level systems security, binary analysis,
fuzzing, and mitigation …</p>

