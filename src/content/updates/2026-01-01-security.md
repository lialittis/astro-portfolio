---
title: Security News – 2026-01-01
date: 2026-01-01
tags: [security, news]
---

## The Hacker News
*Cybersecurity news and insights*

### [Trust Wallet Chrome Extension Hack Drains $8.5M via Shai-Hulud Supply Chain Attack](https://thehackernews.com/2025/12/trust-wallet-chrome-extension-hack.html) - December 31, 2025

Trust Wallet on Tuesday revealed that the second iteration of the Shai-Hulud (aka Sha1-Hulud) supply chain outbreak in November 2025 was likely responsible for the hack of its Google Chrome extension, ultimately resulting in the theft of approximately $8.5 million in assets.
"Our Developer GitHub secrets were exposed in the attack, which gave the attacker access to our browser extension source

### [DarkSpectre Browser Extension Campaigns Exposed After Impacting 8.8 Million Users Worldwide](https://thehackernews.com/2025/12/darkspectre-browser-extension-campaigns.html) - December 31, 2025

The threat actor behind two malicious browser extension campaigns, ShadyPanda and GhostPoster, has been attributed to a third attack campaign codenamed DarkSpectre that has impacted 2.2 million users of Google Chrome, Microsoft Edge, and Mozilla Firefox.
The activity is assessed to be the work of a Chinese threat actor that Koi Security is tracking under the moniker DarkSpectre. In all, the

### [IBM Warns of Critical API Connect Bug Allowing Remote Authentication Bypass](https://thehackernews.com/2025/12/ibm-warns-of-critical-api-connect-bug.html) - December 31, 2025

IBM has disclosed details of a critical security flaw in API Connect that could allow attackers to gain remote access to the application.
The vulnerability, tracked as CVE-2025-13915, is rated 9.8 out of a maximum of 10.0 on the CVSS scoring system. It has been described as an authentication bypass flaw.
"IBM API Connect could allow a remote attacker to bypass authentication mechanisms and gain

### [Researchers Spot Modified Shai-Hulud Worm Testing Payload on npm Registry](https://thehackernews.com/2025/12/researchers-spot-modified-shai-hulud.html) - December 31, 2025

Cybersecurity researchers have disclosed details of what appears to be a new strain of Shai Hulud on the npm registry with slight modifications from the previous wave observed last month.
The npm package that embeds the novel Shai Hulud strain is "@vietmoney/react-big-calendar," which was uploaded to npm back in March 2021 by a user named "hoquocdat." It was updated for the first time on


## Schneier on Security
*Security news and analysis by Bruce Schneier*

### [LinkedIn Job Scams](https://www.schneier.com/blog/archives/2025/12/linkedin-job-scams.html) - December 31, 2025

<p>Interesting <a href="https://restofworld.org/2025/linkedin-job-scams/">article</a> on the variety of LinkedIn job scams around the world:</p>
<blockquote><p>In India, tech jobs are used as bait because the industry employs millions of people and offers high-paying roles. In Kenya, the recruitment industry is largely unorganized, so scamsters leverage fake personal referrals. In Mexico, bad actors capitalize on the informal nature of the job economy by advertising fake formal roles that carry a promise of security. In Nigeria, scamsters often manage to get LinkedIn users to share their login credentials with the lure of paid work, preying on their desperation amid an especially acute unemployment crisis...</p></blockquote>


## Trail of Bits Blog
*Security research and insights from Trail of Bits*

### [Detect Go’s silent arithmetic bugs with go-panikint](https://blog.trailofbits.com/2025/12/31/detect-gos-silent-arithmetic-bugs-with-go-panikint/) - December 31, 2025

<p>Go’s arithmetic operations on standard integer types are silent by default, meaning overflows “wrap around” without panicking. This behavior has hidden an entire class of security vulnerabilities from fuzzing campaigns. Today we’re changing that by releasing <a href="https://github.com/trailofbits/go-panikint">go-panikint</a>, a modified Go compiler that turns silent integer overflows into explicit panics. We used it to find a live integer overflow in the Cosmos SDK’s RPC pagination logic, showing how this approach eliminates a major blind spot for anyone fuzzing Go projects. (The issue in the Cosmos SDK has not been fixed, but a <a href="https://github.com/cosmos/cosmos-sdk/pull/25049">pull request</a> has been created to mitigate it.)</p>
<h2 id="the-sound-of-silence">The sound of silence</h2>
<p>In Rust, debug builds are designed to panic on integer overflow, a feature that is highly valuable for fuzzing. Go, however, takes a different approach. In Go, arithmetic overflows on standard integer types are silent by default. The operations simply “wrap around,” which can be a risky behavior and a potential source of serious vulnerabilities.</p>
<p>This is not an oversight but a deliberate, long-debated <a href="https://github.com/golang/go/issues/30613">design choice</a> in the Go community. While Go’s memory safety prevents entire classes of vulnerabilities, its integers are not safe from overflow. Unchecked arithmetic operations can lead to logic bugs that bypass critical security checks.</p>
<p>Of course, static analysis tools can identify potential integer overflows. The problem is that they often produce a high number of false positives. It’s difficult to know if a flagged line of code is truly reachable by an attacker or if the overflow is actually harmless due to mitigating checks in the surrounding code. Fuzzing, on the other hand, provides a definitive answer: if you can trigger it with a fuzzer, the bug is real and reachable. However, the problem remained that Go’s default behavior wouldn&rsquo;t cause a crash, letting these bugs go undetected.</p>
<h2 id="how-go-panikint-works">How go-panikint works</h2>
<p>To solve this, we forked the Go compiler and modified its backend. The <a href="https://github.com/trailofbits/go-panikint/blob/eb29f694a03fbe38df5ab618acdd0f8b75d4ddd8/src/cmd/compile/internal/ssagen/ssa.go#L5320-L5987">core</a> of go-panikint&rsquo;s functionality is injected during the compiler&rsquo;s conversion of code into <a href="https://en.wikipedia.org/wiki/Static_single-assignment_form">Static Single Assignment</a> (SSA) form, a lower-level intermediate representation (IR). At this stage, for every mathematical operation, our compiler inserts additional checks. If one of these checks fails at runtime, it triggers a panic with a detailed error message. These runtime checks are compiled directly into the final binary.</p>
<p>In addition to arithmetic overflows, go-panikint can also detect integer truncation issues, where converting a value to a smaller integer type causes data loss. Here’s an example:</p>
<figure class="highlight">
 <pre class="chroma" tabindex="0"><code class="language-go"><span class="line"><span class="cl"><span class="kd">var</span><span class="w"> </span><span class="nx">x</span><span class="w"> </span><span class="kt">uint16</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">256</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nx">result</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">uint8</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span><span class="w"> </span></span></span></code></pre>
 <figcaption><span>Figure 1: Conversion leading to data loss due to unsafe casting</span></figcaption>
</figure>
<p>While this feature is functional, we found that it generated false positives during our fuzzing campaigns. For this reason, we will not investigate further and will focus on arithmetic issues.</p>
<p>Let’s analyze the checks for a program that adds up two numbers. If we compile this program and then decompile it, we can clearly see how these checks are inserted. Here, the <code>if</code> condition is used to detect signed integer overflow:</p>
<ul>
<li>
<p>Case 1: Both operands are negative. The result should also be negative. If instead the result (<code>sVar23</code>) becomes larger (less negative or even positive), this indicates signed overflow.</p>
</li>
<li>
<p>Case 2: Both operands are non-negative. The result should be greater than or equal to each operand. If instead the result becomes smaller than one operand, this indicates signed overflow.</p>
</li>
<li>
<p>Case 3: Only one operand is negative. In this case, signed overflow cannot occur.</p>
</li>
</ul>
<figure class="highlight">
 <pre class="chroma" tabindex="0"><code class="language-c"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">x_00</span> <span class="o">==</span> <span class="sc">'+'</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">uint32</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">undefined8</span> <span class="o">*</span><span class="p">)(</span><span class="n">puVar9</span> <span class="o">+</span> <span class="mh">0x60</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> <span class="n">sVar23</span> <span class="o">=</span> <span class="n">val</span> <span class="o">+</span> <span class="n">sVar21</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="n">puVar17</span> <span class="o">=</span> <span class="n">puVar9</span> <span class="o">+</span> <span class="mi">8</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="k">if</span> <span class="p">(((</span><span class="n">sdword</span><span class="p">)</span><span class="n">val</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">sVar21</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">sdword</span><span class="p">)</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">sVar23</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl"> <span class="p">((</span><span class="n">sdword</span><span class="p">)</span><span class="n">val</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">sVar21</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">sVar23</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">sdword</span><span class="p">)</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="n">runtime</span><span class="p">.</span><span class="nf">panicoverflow</span><span class="p">();</span> <span class="c1">// &lt;-- panic if overflow caught
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"> <span class="k">goto</span> <span class="n">LAB_1000a10d4</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre>
 <figcaption><span>Figure 2: Example of a decompiled multiplication from a Go program</span></figcaption>
</figure>
<p>Using go-panikint is straightforward. You simply compile the tool and then use the resulting Go binary in place of the official one. All other commands and build processes remain exactly the same, making it easy to integrate into existing workflows.</p>
<figure class="highlight">
 <pre class="chroma" tabindex="0"><code class="language-shell"><span class="line"><span class="cl">git clone https://github.com/trailofbits/go-panikint
</span></span><span class="line"><span class="cl"><span class="nb">cd</span> go-panikint/src <span class="o">&amp;&amp;</span> ./make.bash
</span></span><span class="line"><span class="cl"><span class="nb">export</span> <span class="nv">GOROOT</span><span class="o">=</span>/path/to/go-panikint <span class="c1"># path to the root of go-panikint</span>
</span></span><span class="line"><span class="cl">./bin/go <span class="nb">test</span> -fuzz<span class="o">=</span>FuzzIntegerOverflow <span class="c1"># fuzz our harness</span></span></span></code></pre>
 <figcaption><span>Figure 3: Installation and usage of go-panikint</span></figcaption>
</figure>
<p>Let’s try with a very simple program. This program has no fuzzing harness, only a main function to execute for illustration purposes.</p>
<figure class="highlight">
 <pre class="chroma" tabindex="0"><code class="language-go"><span class="line"><span class="cl"><span class="kn">package</span><span class="w"> </span><span class="nx">main</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kn">import</span><span class="w"> </span><span class="s">"fmt"</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">func</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="kd">var</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="kt">int8</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">120</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="kd">var</span><span class="w"> </span><span class="nx">b</span><span class="w"> </span><span class="kt">int8</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">20</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="nx">result</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">b</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">"%d + %d = %d\n"</span><span class="p">,</span><span class="w"> </span><span class="nx">a</span><span class="p">,</span><span class="w"> </span><span class="nx">b</span><span class="p">,</span><span class="w"> </span><span class="nx">result</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span></span></span></code></pre>
 <figcaption><span>Figure 4: Simple integer overflow bug</span></figcaption>
</figure>
<figure class="highlight">
 <pre class="chroma" tabindex="0"><code class="language-shell"><span class="line"><span class="cl">$ go run poc.go <span class="c1"># native compiler </span>
</span></span><span class="line"><span class="cl"><span class="m">120</span> + <span class="nv">20</span> <span class="o">=</span> -116
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ <span class="nv">GOROOT</span><span class="o">=</span><span class="nv">$pwd</span> ./bin/go run poc.go <span class="c1"># go-panikint</span>
</span></span><span class="line"><span class="cl">panic: runtime error: integer overflow in int8 addition operation
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">goroutine <span class="m">1</span> <span class="o">[</span>running<span class="o">]</span>:
</span></span><span class="line"><span class="cl">main.main<span class="o">()</span>
</span></span><span class="line"><span class="cl">	./go-panikint/poc.go:8 +0xb8
</span></span><span class="line"><span class="cl"><span class="nb">exit</span> status <span class="m">2</span></span></span></code></pre>
 <figcaption><span>Figure 5: Running poc.go with both compilers</span></figcaption>
</figure>
<p>However, not all overflows are bugs; some are intentional, especially in low-level code like the Go compiler itself, used for randomness or cryptographic algorithms. To handle these cases, we built two filtering mechanisms:</p>
<ol>
<li>
<p>Source-location-based filtering: This allows us to ignore known, intentional overflows within the Go compiler&rsquo;s own source code by whitelisting some given file paths.</p>
</li>
<li>
<p>In-code comments: Any arithmetic operation can be marked as a non-issue by adding a simple comment, like <code>// overflow_false_positive</code> or <code>// truncation_false_positive</code>. This prevents <code>go-panikint</code> from panicking on code that relies on wrapping behavior.</p>
</li>
</ol>
<h2 id="finding-a-real-world-bug">Finding a real-world bug</h2>
<p>To validate our tool, we used it in a fuzzing campaign against the Cosmos SDK and discovered an <a href="https://github.com/cosmos/cosmos-sdk/issues/25006">integer overflow vulnerability</a> in the RPC pagination logic. When the sum of the offset and limit parameters in a query exceeded the maximum value for a <code>uint64</code>, the query would return an empty list of validators instead of the expected set.</p>
<figure class="highlight">
 <pre class="chroma" tabindex="0"><code class="language-go"><span class="line"><span class="cl"><span class="c1">// Paginate does pagination of all the results in the PrefixStore based on the</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// provided PageRequest. onResult should be used to do actual unmarshaling.</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">func</span><span class="w"> </span><span class="nf">Paginate</span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="nx">prefixStore</span><span class="w"> </span><span class="nx">types</span><span class="p">.</span><span class="nx">KVStore</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="nx">pageRequest</span><span class="w"> </span><span class="o">*</span><span class="nx">PageRequest</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="nx">onResult</span><span class="w"> </span><span class="kd">func</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span><span class="w"> </span><span class="nx">value</span><span class="w"> </span><span class="p">[]</span><span class="kt">byte</span><span class="p">)</span><span class="w"> </span><span class="kt">error</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="nx">PageResponse</span><span class="p">,</span><span class="w"> </span><span class="kt">error</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="o">...</span><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nx">end</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">pageRequest</span><span class="p">.</span><span class="nx">Offset</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">pageRequest</span><span class="p">.</span><span class="nx">Limit</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="o">...</span><span class="w"> </span></span></span></code></pre>
 <figcaption><span>Figure 6: end can overflow uint64 and return an empty validator list if user provides a large Offset</span></figcaption>
</figure>
<p>This finding demonstrates the power of combining fuzzing with runtime checks: <code>go-panikint</code> turned the silent overflow into a clear panic, which the fuzzer reported as a crash with a reproducible test case. A <a href="https://github.com/cosmos/cosmos-sdk/pull/25049">pull request</a> has been created to mitigate the issue.</p>
<h2 id="use-cases-for-researchers-and-developers">Use cases for researchers and developers</h2>
<p>We built <code>go-panikint</code> with two main use cases in mind:</p>
<ol>
<li>
<p><strong>Security research and fuzzing:</strong> For security researchers, <code>go-panikint</code> is a great new tool for bug discovery. By simply replacing the Go compiler in a fuzzing environment, researchers can uncover two whole new classes of vulnerabilities that were previously invisible to dynamic analysis.</p>
</li>
<li>
<p><strong>Continuous deployment and integration:</strong> Developers can integrate <code>go-panikint</code> into their CI/CD pipelines and potentially uncover bugs that standard test runs would miss.</p>
</li>
</ol>
<p>We invite the community to try <code>go-panikint</code> on your own projects, integrate it into your CI pipelines, and help us uncover the next wave of hidden arithmetic bugs.</p>


## SecurityWeek
*Latest cybersecurity news*

### [Shai-Hulud Supply Chain Attack Led to $8.5 Million Trust Wallet Heist](https://www.securityweek.com/shai-hulud-supply-chain-attack-led-to-8-5-million-trust-wallet-heist/) - December 31, 2025

<p>The worm exposed Trust Wallet’s Developer GitHub secrets, allowing attackers to publish a backdoor extension and steal funds from 2,520 wallets.</p>
<p>The post <a href="https://www.securityweek.com/shai-hulud-supply-chain-attack-led-to-8-5-million-trust-wallet-heist/">Shai-Hulud Supply Chain Attack Led to $8.5 Million Trust Wallet Heist</a> appeared first on <a href="https://www.securityweek.com">SecurityWeek</a>.</p>

### [European Space Agency Confirms Breach After Hacker Offers to Sell Data](https://www.securityweek.com/european-space-agency-confirms-breach-after-hacker-offers-to-sell-data/) - December 31, 2025

<p>The European Space Agency is conducting an investigation and says external science servers have been compromised.</p>
<p>The post <a href="https://www.securityweek.com/european-space-agency-confirms-breach-after-hacker-offers-to-sell-data/">European Space Agency Confirms Breach After Hacker Offers to Sell Data</a> appeared first on <a href="https://www.securityweek.com">SecurityWeek</a>.</p>

